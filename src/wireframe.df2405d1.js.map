{"mappings":"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","sources":["node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","node_modules/three/examples/jsm/lines/LineMaterial.js","node_modules/three/examples/jsm/lines/LineSegments2.js","node_modules/three/examples/jsm/lines/LineGeometry.js","node_modules/three/examples/jsm/lines/Line2.js","node_modules/@parcel/runtime-js/lib/bundle-url.js","node_modules/@parcel/runtime-js/lib/runtime-8205e49216cd2f2f6f3c26d745e6835a.js","examples/src/wireframe.js"],"sourcesContent":["import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from 'three';\n\nconst _box = new Box3();\nconst _vector = new Vector3();\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tconst positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tconst uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tconst index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\tlet lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\tlet colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t}\n\n\tfromWireframeGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromEdgesGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromMesh( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tfromLineSegments( lineSegments ) {\n\n\t\tconst geometry = lineSegments.geometry;\n\n\t\tif ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t}\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t_box.setFromBufferAttribute( end );\n\n\t\t\tthis.boundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( start, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t_vector.fromBufferAttribute( end, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\t// todo\n\n\t}\n\n\tapplyMatrix( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n}\n\nLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n\nexport { LineSegmentsGeometry };\n","import {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2\n} from 'three';\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nUniformsLib.line = {\n\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tdashOffset: { value: 0 },\n\tgapSize: { value: 1 }, // todo FIX - maybe change to totalSize\n\topacity: { value: 1 }\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t\t`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t\t`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\tfloat a = vUv.x;\n\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\tfloat len2 = a * a + b * b;\n\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t}\n\n\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttype: 'LineMaterial',\n\n\t\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\t\tclipping: true // required for clipping support\n\n\t\t} );\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tcolor: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.diffuse.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tlinewidth: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.linewidth.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.linewidth.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tdashed: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn Boolean( 'USE_DASH' in this.defines );\n\n\t\t\t\t},\n\n\t\t\t\tset( value ) {\n\n\t\t\t\t\tif ( Boolean( value ) !== Boolean( 'USE_DASH' in this.defines ) ) {\n\n\t\t\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( value === true ) {\n\n\t\t\t\t\t\tthis.defines.USE_DASH = '';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_DASH;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tdashScale: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.dashScale.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.dashScale.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tdashSize: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.dashSize.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.dashSize.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tdashOffset: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.dashOffset.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.dashOffset.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tgapSize: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.gapSize.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.gapSize.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\topacity: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tresolution: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.resolution.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.resolution.value.copy( value );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\talphaToCoverage: {\n\n\t\t\t\tenumerable: true,\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn Boolean( 'ALPHA_TO_COVERAGE' in this.defines );\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tif ( Boolean( value ) !== Boolean( 'ALPHA_TO_COVERAGE' in this.defines ) ) {\n\n\t\t\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( value === true ) {\n\n\t\t\t\t\t\tthis.defines.ALPHA_TO_COVERAGE = '';\n\t\t\t\t\t\tthis.extensions.derivatives = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.ALPHA_TO_COVERAGE;\n\t\t\t\t\t\tthis.extensions.derivatives = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nLineMaterial.prototype.isLineMaterial = true;\n\nexport { LineMaterial };\n","import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\tconst ray = raycaster.ray;\n\t\tconst camera = raycaster.camera;\n\t\tconst projectionMatrix = camera.projectionMatrix;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst resolution = material.resolution;\n\t\tconst lineWidth = material.linewidth + threshold;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\n\t\t// camera forward is negative\n\t\tconst near = - camera.near;\n\n\t\t// clip space is [ - 1, 1 ] so multiply by two to get the full\n\t\t// width in clip space\n\t\tconst ssMaxWidth = 2.0 * Math.max( lineWidth / resolution.width, lineWidth / resolution.height );\n\n\t\t//\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( ray.origin ) );\n\n\t\t// get the w component to scale the world space line width\n\t\t_clipToWorldVector.set( 0, 0, - distanceToSphere, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tconst sphereMargin = Math.abs( ssMaxWidth / _clipToWorldVector.w ) * 0.5;\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t//\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( ray.origin ) );\n\n\t\t// get the w component to scale the world space line width\n\t\t_clipToWorldVector.set( 0, 0, - distanceToBox, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tconst boxMargin = Math.abs( ssMaxWidth / _clipToWorldVector.w ) * 0.5;\n\t\t_box.max.x += boxMargin;\n\t\t_box.max.y += boxMargin;\n\t\t_box.max.z += boxMargin;\n\t\t_box.min.x -= boxMargin;\n\t\t_box.min.y -= boxMargin;\n\t\t_box.min.z -= boxMargin;\n\n\t\tif ( raycaster.ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t//\n\n\t\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t\t// applying the projection matrix.\n\t\tray.at( 1, _ssOrigin );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_ssOrigin.w = 1;\n\t\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t\t// screen space\n\t\t_ssOrigin.x *= resolution.x / 2;\n\t\t_ssOrigin.y *= resolution.y / 2;\n\t\t_ssOrigin.z = 0;\n\n\t\t_ssOrigin3.copy( _ssOrigin );\n\n\t\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\t\tfor ( let i = 0, l = instanceStart.count; i < l; i ++ ) {\n\n\t\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_start4.w = 1;\n\t\t\t_end4.w = 1;\n\n\t\t\t// camera space\n\t\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t\t// skip the segment if it's entirely behind the camera\n\t\t\tvar isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\t\tif ( isBehindCameraNear ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// trim the segment if it extends behind camera near\n\t\t\tif ( _start4.z > near ) {\n\n\t\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t\t_start4.lerp( _end4, t );\n\n\t\t\t} else if ( _end4.z > near ) {\n\n\t\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t\t_end4.lerp( _start4, t );\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t\t// screen space\n\t\t\t_start4.x *= resolution.x / 2;\n\t\t\t_start4.y *= resolution.y / 2;\n\n\t\t\t_end4.x *= resolution.x / 2;\n\t\t\t_end4.y *= resolution.y / 2;\n\n\t\t\t// create 2d segment\n\t\t\t_line.start.copy( _start4 );\n\t\t\t_line.start.z = 0;\n\n\t\t\t_line.end.copy( _end4 );\n\t\t\t_line.end.z = 0;\n\n\t\t\t// get closest point on ray to segment\n\t\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t\t_line.at( param, _closestPoint );\n\n\t\t\t// check if the intersection point is within clip space\n\t\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < lineWidth * 0.5;\n\n\t\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\t\tconst pointOnLine = new Vector3();\n\t\t\t\tconst point = new Vector3();\n\n\t\t\t\tray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tpoint: point,\n\t\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\t\tdistance: ray.origin.distanceTo( point ),\n\n\t\t\t\t\tobject: this,\n\t\t\t\t\tface: null,\n\t\t\t\t\tfaceIndex: i,\n\t\t\t\t\tuv: null,\n\t\t\t\t\tuv2: null,\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nLineSegments2.prototype.LineSegments2 = true;\n\nexport { LineSegments2 };\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\n\nclass LineGeometry extends LineSegmentsGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.type = 'LineGeometry';\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n\t\tvar length = array.length - 3;\n\t\tvar points = new Float32Array( 2 * length );\n\n\t\tfor ( var i = 0; i < length; i += 3 ) {\n\n\t\t\tpoints[ 2 * i ] = array[ i ];\n\t\t\tpoints[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tpoints[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tpoints[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tpoints[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tpoints[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setPositions( points );\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n\n\t\tvar length = array.length - 3;\n\t\tvar colors = new Float32Array( 2 * length );\n\n\t\tfor ( var i = 0; i < length; i += 3 ) {\n\n\t\t\tcolors[ 2 * i ] = array[ i ];\n\t\t\tcolors[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tcolors[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tcolors[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tcolors[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tcolors[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tsuper.setColors( colors );\n\n\t\treturn this;\n\n\t}\n\n\tfromLine( line ) {\n\n\t\tvar geometry = line.geometry;\n\n\t\tif ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t}\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n}\n\nLineGeometry.prototype.isLineGeometry = true;\n\nexport { LineGeometry };\n","import { LineSegments2 } from '../lines/LineSegments2.js';\nimport { LineGeometry } from '../lines/LineGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nclass Line2 extends LineSegments2 {\n\n\tconstructor( geometry = new LineGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'Line2';\n\n\t}\n\n}\n\nLine2.prototype.isLine2 = true;\n\nexport { Line2 };\n","\"use strict\";\n\n/* globals document:readonly */\nvar bundleURL = null;\n\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp):\\/\\/[^)\\n]+/g);\n\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\n\n\nfunction getOrigin(url) {\n  let matches = ('' + url).match(/(https?|file|ftp):\\/\\/[^/]+/);\n\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n\n  return matches[0];\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","module.exports = require('./bundle-url').getBundleURL() + \"../ubi-icon.43528307.png\"","import {\n  Mesh,\n  MeshStandardMaterial,\n  Vector3,\n  LineMaterial,\n  Shape,\n  ExtrudeGeometry,\n  TextureLoader,\n  MeshBasicMaterial,\n  PlaneGeometry,\n  Color\n} from 'three';\nimport {LineSegmentsGeometry} from 'three/examples/jsm/lines/LineSegmentsGeometry';\nimport {Line2} from 'three/examples/jsm/lines/Line2.js';\nimport {LineMaterial} from 'three/examples/jsm/lines/LineMaterial.js';\nimport UBI_ICON from 'url:../assets/ubi-icon.png';\nimport ThreeJSOverlayView from '@ubilabs/threejs-overlay-view';\n\nimport {getMapsApiOptions, loadMapsApi} from '../jsm/load-maps-api';\n\nconst initialViewport = {\n  center: {\n    lat: 53.55493986295417,\n    lng: 10.007137126703523\n  },\n  heading: 324.66666666666674,\n  tilt: 65.66666666666667,\n  zoom: 19.43375\n};\n\nconst BUILDING_HEIGHT = 31;\nconst BUILDING_LINE_COLOR = 0xffffff;\nconst BUILDING_FILL_COLOR = 0x000000;\nconst Z_FIGHTING_OFFSET = 0.001;\nconst LOGO_SIZE = [16, 16];\nconst LOGO_POSITION = {\n  lat: 53.55463986295417,\n  lng: 10.007317126703523,\n  altitude: BUILDING_HEIGHT + Z_FIGHTING_OFFSET\n};\nconst LOGO_ROTATION_Z = Math.PI / 12;\nconst COLOR_CHANGE_DURATION = 30; // completes one hue cycle in x seconds\n\nasync function main() {\n  const {mapId} = getMapsApiOptions();\n  await loadMapsApi();\n\n  const mapContainer = document.querySelector('#map');\n  const map = new google.maps.Map(mapContainer, {\n    mapId,\n    ...initialViewport\n  });\n\n  const overlay = new ThreeJSOverlayView(initialViewport.center);\n  overlay.setMap(map);\n\n  initScene(overlay, mapContainer).then(() => overlay.requestRedraw());\n}\n\nasync function initScene(overlay, mapContainer) {\n  const scene = overlay.getScene();\n\n  const wireframePath = [\n    [10.00787808793857, 53.554574397774715],\n    [10.006971374559072, 53.55444226566294],\n    [10.006565280581388, 53.55467172811441],\n    [10.006569569754523, 53.55471724470295],\n    [10.007768697370686, 53.554874083634],\n    [10.007848668422987, 53.554846301309745],\n    [10.007913475744536, 53.554604563663226]\n  ];\n  const points = wireframePath.map(([lng, lat]) =>\n    overlay.latLngAltToVector3({lat, lng})\n  );\n\n  const line = getWireframe(points);\n  scene.add(line);\n  scene.add(getBuilding(points));\n  scene.add(await getLogo(overlay));\n\n  overlay.update = () => {\n    const time = performance.now();\n\n    line.material.resolution.copy(overlay.getViewportSize());\n    line.material.color.setHSL(\n      ((time * 0.36) / COLOR_CHANGE_DURATION) % 1,\n      0.69,\n      0.5\n    );\n\n    overlay.requestRedraw();\n  };\n}\n\nfunction getWireframe(points) {\n  const positions = new Float32Array(18 * points.length).fill(0);\n\n  const offset = new Vector3(0, 0, BUILDING_HEIGHT);\n  const pointsTop = points.map(p => p.clone().add(offset));\n\n  for (let i = 0, n = points.length; i < n; i++) {\n    points[i].toArray(positions, 6 * i);\n    points[(i + 1) % n].toArray(positions, 6 * i + 3);\n  }\n\n  let topOffset = points.length * 6;\n  for (let i = 0, n = pointsTop.length; i < n; i++) {\n    pointsTop[i].toArray(positions, topOffset + 6 * i);\n    pointsTop[(i + 1) % n].toArray(positions, topOffset + 6 * i + 3);\n  }\n\n  let vertEdgeOffset = points.length * 12;\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    const pTop = pointsTop[i];\n\n    p.toArray(positions, vertEdgeOffset + 6 * i);\n    pTop.toArray(positions, vertEdgeOffset + 6 * i + 3);\n  }\n\n  const lineGeometry = new LineSegmentsGeometry();\n  lineGeometry.instanceCount = 3 * points.length;\n  lineGeometry.setPositions(positions);\n  const lineMaterial = new LineMaterial({\n    color: BUILDING_LINE_COLOR,\n    linewidth: 2\n  });\n\n  const line = new Line2(lineGeometry, lineMaterial);\n  line.computeLineDistances();\n  return line;\n}\n\nfunction getBuilding(points) {\n  const buildingMaterial = new MeshStandardMaterial({\n    transparent: true,\n    opacity: 0.5,\n    color: BUILDING_FILL_COLOR\n  });\n\n  const buildingShape = new Shape();\n  points.forEach((p, i) => {\n    i === 0 ? buildingShape.moveTo(p.x, p.y) : buildingShape.lineTo(p.x, p.y);\n  });\n\n  const extrudeSettings = {\n    depth: BUILDING_HEIGHT,\n    bevelEnabled: false\n  };\n  const buildingGeometry = new ExtrudeGeometry(buildingShape, extrudeSettings);\n  return new Mesh(buildingGeometry, buildingMaterial);\n}\n\nfunction getLogo(overlay) {\n  return new Promise(resolve => {\n    const loader = new TextureLoader();\n    loader.load(UBI_ICON, texture => {\n      const logoGeometry = new PlaneGeometry(...LOGO_SIZE);\n      const logoMaterial = new MeshBasicMaterial({\n        map: texture,\n        transparent: true\n      });\n      const logo = new Mesh(logoGeometry, logoMaterial);\n      overlay.latLngAltToVector3(LOGO_POSITION, logo.position);\n      logo.rotateZ(LOGO_ROTATION_Z);\n      resolve(logo);\n    });\n  });\n}\n\nmain().catch(err => {\n  console.error('uncaught error in main: ', err);\n});\n"],"names":["$684a85b3675221e42b9bb3319badcb65$var$_box","Box3","$684a85b3675221e42b9bb3319badcb65$var$_vector","$7J8MZ","Vector3","$684a85b3675221e42b9bb3319badcb65$export$c35550274c1cc91b","InstancedBufferGeometry","super","type","setIndex","setAttribute","Float32BufferAttribute","[object Object]","matrix","start","this","attributes","instanceStart","end","instanceEnd","undefined","applyMatrix4","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","colors","instanceColorBuffer","geometry","setPositions","position","mesh","fromWireframeGeometry","WireframeGeometry","isGeometry","isBufferGeometry","console","error","setFromBufferAttribute","union","Sphere","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","warn","prototype","isLineSegmentsGeometry","UniformsLib","line","linewidth","value","resolution","Vector2","dashScale","dashSize","dashOffset","gapSize","opacity","ShaderLib","uniforms","UniformsUtils","merge","common","fog","vertexShader","fragmentShader","$ad4ed936ea1c0ecee3c47f8670e640c6$export$602a1624b0426cc4","ShaderMaterial","parameters","clone","clipping","Object","defineProperties","color","enumerable","get","diffuse","set","dashed","Boolean","defines","USE_DASH","copy","alphaToCoverage","ALPHA_TO_COVERAGE","extensions","derivatives","setValues","isLineMaterial","$99769004a0c3db1fafcdb8b0230d4e21$var$_start","$99769004a0c3db1fafcdb8b0230d4e21$var$_end","$99769004a0c3db1fafcdb8b0230d4e21$var$_start4","Vector4","$99769004a0c3db1fafcdb8b0230d4e21$var$_end4","$99769004a0c3db1fafcdb8b0230d4e21$var$_ssOrigin","$99769004a0c3db1fafcdb8b0230d4e21$var$_ssOrigin3","$99769004a0c3db1fafcdb8b0230d4e21$var$_mvMatrix","Matrix4","$99769004a0c3db1fafcdb8b0230d4e21$var$_line","Line3","$99769004a0c3db1fafcdb8b0230d4e21$var$_closestPoint","$99769004a0c3db1fafcdb8b0230d4e21$var$_box","$99769004a0c3db1fafcdb8b0230d4e21$var$_sphere","$99769004a0c3db1fafcdb8b0230d4e21$var$_clipToWorldVector","$99769004a0c3db1fafcdb8b0230d4e21$export$d276d9e8d913f8b8","Mesh","material","random","geometry1","lineDistances","j","l","distanceTo","instanceDistanceBuffer","raycaster","intersects","camera","threshold","params","Line2","ray","projectionMatrix","matrixWorld","material1","lineWidth","near","ssMaxWidth","width","height","distanceToSphere","distanceToPoint","origin","multiplyScalar","w","projectionMatrixInverse","sphereMargin","abs","intersectsSphere","distanceToBox","boxMargin","x","y","z","min","intersectsBox","at","matrixWorldInverse","multiplyMatrices","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","MathUtils","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","object","face","faceIndex","uv","uv2","LineSegments2","$9257fabaad3735fcb8793becb4bc4a5f$export$60bfee21765a6ceb","length","points","setColors","isLineGeometry","$3113f2d8709430d79b6c91fece2b6c16$export$77287a2157061359","isLine2","$10da859f8926f997eca867931986be87$var$bundleURL","$10da859f8926f997eca867931986be87$var$getBaseURL","url","replace","$10da859f8926f997eca867931986be87$export$da289beea9c5b10d","Error","err","matches","stack","match","$10da859f8926f997eca867931986be87$var$getBundleURL","$94c5d853e4eff473ad48abbf603b04d0$exports","parcelRequire","getBundleURL","$ca18d908b91fd15fbb8ff28ba0ab912d$var$initialViewport","lat","lng","heading","tilt","zoom","$ca18d908b91fd15fbb8ff28ba0ab912d$var$LOGO_SIZE","$ca18d908b91fd15fbb8ff28ba0ab912d$var$LOGO_POSITION","altitude","$ca18d908b91fd15fbb8ff28ba0ab912d$var$BUILDING_HEIGHT","$ca18d908b91fd15fbb8ff28ba0ab912d$var$LOGO_ROTATION_Z","PI","mapId","$2ZjD0","getMapsApiOptions","loadMapsApi","mapContainer","document","querySelector","map","google","maps","Map","overlay","$1AtD0","default","setMap","scene","getScene","latLngAltToVector3","positions","fill","offset","pointsTop","p","add","n","toArray","topOffset","i1","n1","vertEdgeOffset","i2","pTop","lineGeometry","instanceCount","lineMaterial","computeLineDistances","$ca18d908b91fd15fbb8ff28ba0ab912d$var$getWireframe","buildingMaterial","MeshStandardMaterial","transparent","buildingShape","Shape","forEach","moveTo","lineTo","extrudeSettings","depth","bevelEnabled","buildingGeometry","ExtrudeGeometry","$ca18d908b91fd15fbb8ff28ba0ab912d$var$getBuilding","Promise","resolve","TextureLoader","load","$parcel$interopDefault","texture","logoGeometry","PlaneGeometry","logoMaterial","MeshBasicMaterial","logo","rotateZ","$ca18d908b91fd15fbb8ff28ba0ab912d$var$getLogo","update","time","performance","now","getViewportSize","setHSL","requestRedraw","$ca18d908b91fd15fbb8ff28ba0ab912d$var$initScene","then","$ca18d908b91fd15fbb8ff28ba0ab912d$var$main","catch"],"version":3,"file":"wireframe.df2405d1.js.map"}