function t(t){return t&&t.__esModule?t.default:t}var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},n={},i={},r=e.parcelRequire269f;null==r&&((r=function(t){if(t in n)return n[t].exports;if(t in i){let e=i[t];delete i[t];let r={id:t,exports:{}};return n[t]=r,e.call(r.exports,r,r.exports),r.exports}var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}).register=function(t,e){i[t]=e},e.parcelRequire269f=r);var a=r("7J8MZ");const o=new((a=r("7J8MZ")).Box3),s=new a.Vector3;class l extends a.InstancedBufferGeometry{constructor(){super(),this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new a.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new a.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const n=new a.InstancedInterleavedBuffer(e,6,1);return this.setAttribute("instanceStart",new a.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceEnd",new a.InterleavedBufferAttribute(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const n=new a.InstancedInterleavedBuffer(e,6,1);return this.setAttribute("instanceColorStart",new a.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceColorEnd",new a.InterleavedBufferAttribute(n,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new a.WireframeGeometry(t.geometry)),this}fromLineSegments(t){const e=t.geometry;if(!e.isGeometry)return e.isBufferGeometry&&this.setPositions(e.attributes.position.array),this;console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.")}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new a.Box3);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),o.setFromBufferAttribute(e),this.boundingBox.union(o))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new a.Sphere),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let i=0;for(let r=0,a=t.count;r<a;r++)s.fromBufferAttribute(t,r),i=Math.max(i,n.distanceToSquared(s)),s.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(s));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(t){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(t)}}l.prototype.isLineSegmentsGeometry=!0;a=r("7J8MZ");(a=r("7J8MZ")).UniformsLib.line={linewidth:{value:1},resolution:{value:new a.Vector2(1,1)},dashScale:{value:1},dashSize:{value:1},dashOffset:{value:0},gapSize:{value:1},opacity:{value:1}},a.ShaderLib.line={uniforms:a.UniformsUtils.merge([a.UniformsLib.common,a.UniformsLib.fog,a.UniformsLib.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\tfloat a = vUv.x;\n\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\tfloat len2 = a * a + b * b;\n\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t}\n\n\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};class c extends a.ShaderMaterial{constructor(t){super({type:"LineMaterial",uniforms:a.UniformsUtils.clone(a.ShaderLib.line.uniforms),vertexShader:a.ShaderLib.line.vertexShader,fragmentShader:a.ShaderLib.line.fragmentShader,clipping:!0}),Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashed:{enumerable:!0,get:function(){return Boolean("USE_DASH"in this.defines)},set(t){Boolean(t)!==Boolean("USE_DASH"in this.defines)&&(this.needsUpdate=!0),!0===t?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},alphaToCoverage:{enumerable:!0,get:function(){return Boolean("ALPHA_TO_COVERAGE"in this.defines)},set:function(t){Boolean(t)!==Boolean("ALPHA_TO_COVERAGE"in this.defines)&&(this.needsUpdate=!0),!0===t?(this.defines.ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(t)}}c.prototype.isLineMaterial=!0;const u=new a.Vector3,d=new a.Vector3,f=new a.Vector4,p=new a.Vector4,h=new a.Vector4,m=new a.Vector3,y=new a.Matrix4,v=new a.Line3,g=new a.Vector3,b=new a.Box3,x=new a.Sphere,S=new a.Vector4;class w extends a.Mesh{constructor(t=new l,e=new c({color:16777215*Math.random()})){super(t,e),this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,n=t.attributes.instanceEnd,i=new Float32Array(2*e.count);for(let t=0,r=0,a=e.count;t<a;t++,r+=2)u.fromBufferAttribute(e,t),d.fromBufferAttribute(n,t),i[r]=0===r?0:i[r-1],i[r+1]=i[r]+u.distanceTo(d);const r=new a.InstancedInterleavedBuffer(i,2,1);return t.setAttribute("instanceDistanceStart",new a.InterleavedBufferAttribute(r,1,0)),t.setAttribute("instanceDistanceEnd",new a.InterleavedBufferAttribute(r,1,1)),this}raycast(t,e){null===t.camera&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');const n=void 0!==t.params.Line2&&t.params.Line2.threshold||0,i=t.ray,r=t.camera,o=r.projectionMatrix,s=this.matrixWorld,l=this.geometry,c=this.material,u=c.resolution,d=c.linewidth+n,w=l.attributes.instanceStart,A=l.attributes.instanceEnd,M=-r.near,B=2*Math.max(d/u.width,d/u.height);null===l.boundingSphere&&l.computeBoundingSphere(),x.copy(l.boundingSphere).applyMatrix4(s);const E=Math.max(r.near,x.distanceToPoint(i.origin));S.set(0,0,-E,1).applyMatrix4(r.projectionMatrix),S.multiplyScalar(1/S.w),S.applyMatrix4(r.projectionMatrixInverse);const _=.5*Math.abs(B/S.w);if(x.radius+=_,!1===t.ray.intersectsSphere(x))return;null===l.boundingBox&&l.computeBoundingBox(),b.copy(l.boundingBox).applyMatrix4(s);const L=Math.max(r.near,b.distanceToPoint(i.origin));S.set(0,0,-L,1).applyMatrix4(r.projectionMatrix),S.multiplyScalar(1/S.w),S.applyMatrix4(r.projectionMatrixInverse);const z=.5*Math.abs(B/S.w);if(b.max.x+=z,b.max.y+=z,b.max.z+=z,b.min.x-=z,b.min.y-=z,b.min.z-=z,!1!==t.ray.intersectsBox(b)){i.at(1,h),h.w=1,h.applyMatrix4(r.matrixWorldInverse),h.applyMatrix4(o),h.multiplyScalar(1/h.w),h.x*=u.x/2,h.y*=u.y/2,h.z=0,m.copy(h),y.multiplyMatrices(r.matrixWorldInverse,s);for(let t=0,n=w.count;t<n;t++){if(f.fromBufferAttribute(w,t),p.fromBufferAttribute(A,t),f.w=1,p.w=1,f.applyMatrix4(y),p.applyMatrix4(y),f.z>M&&p.z>M)continue;if(f.z>M){const t=f.z-p.z,e=(f.z-M)/t;f.lerp(p,e)}else if(p.z>M){const t=p.z-f.z,e=(p.z-M)/t;p.lerp(f,e)}f.applyMatrix4(o),p.applyMatrix4(o),f.multiplyScalar(1/f.w),p.multiplyScalar(1/p.w),f.x*=u.x/2,f.y*=u.y/2,p.x*=u.x/2,p.y*=u.y/2,v.start.copy(f),v.start.z=0,v.end.copy(p),v.end.z=0;const n=v.closestPointToPointParameter(m,!0);v.at(n,g);const r=a.MathUtils.lerp(f.z,p.z,n),l=r>=-1&&r<=1,c=m.distanceTo(g)<.5*d;if(l&&c){v.start.fromBufferAttribute(w,t),v.end.fromBufferAttribute(A,t),v.start.applyMatrix4(s),v.end.applyMatrix4(s);const n=new a.Vector3,r=new a.Vector3;i.distanceSqToSegment(v.start,v.end,r,n),e.push({point:r,pointOnLine:n,distance:i.origin.distanceTo(r),object:this,face:null,faceIndex:t,uv:null,uv2:null})}}}}}w.prototype.LineSegments2=!0;class A extends l{constructor(){super(),this.type="LineGeometry"}setPositions(t){for(var e=t.length-3,n=new Float32Array(2*e),i=0;i<e;i+=3)n[2*i]=t[i],n[2*i+1]=t[i+1],n[2*i+2]=t[i+2],n[2*i+3]=t[i+3],n[2*i+4]=t[i+4],n[2*i+5]=t[i+5];return super.setPositions(n),this}setColors(t){for(var e=t.length-3,n=new Float32Array(2*e),i=0;i<e;i+=3)n[2*i]=t[i],n[2*i+1]=t[i+1],n[2*i+2]=t[i+2],n[2*i+3]=t[i+3],n[2*i+4]=t[i+4],n[2*i+5]=t[i+5];return super.setColors(n),this}fromLine(t){var e=t.geometry;if(!e.isGeometry)return e.isBufferGeometry&&this.setPositions(e.attributes.position.array),this;console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.")}}A.prototype.isLineGeometry=!0;class M extends w{constructor(t=new A,e=new c({color:16777215*Math.random()})){super(t,e),this.type="Line2"}}M.prototype.isLine2=!0;var B;r.register("vNK0r",(function(t,e){var n,i,r,a,o;n=t.exports,i="getBundleURL",r=()=>o,a=t=>o=t,Object.defineProperty(n,i,{get:r,set:a,enumerable:!0,configurable:!0});var s=null;function l(t){return(""+t).replace(/^((?:https?|file|ftp):\/\/.+)\/[^/]+$/,"$1")+"/"}o=function(){return s||(s=function(){try{throw new Error}catch(e){var t=(""+e.stack).match(/(https?|file|ftp):\/\/[^)\n]+/g);if(t)return l(t[0])}return"/"}()),s}})),B=r("vNK0r").getBundleURL()+"ubi-icon.43528307.png";var E=r("1AtD0"),_=r("2ZjD0");const L={center:{lat:53.55493986295417,lng:10.007137126703523},heading:324.66666666666674,tilt:65.66666666666667,zoom:19.43375},z=[16,16],U={lat:53.55463986295417,lng:10.007317126703523,altitude:31.001},T=Math.PI/12;(async function(){const{mapId:e}=_.getMapsApiOptions();await _.loadMapsApi();const n=document.querySelector("#map"),i=new google.maps.Map(n,{mapId:e,...L}),r=new E.default(L.center);r.setMap(i),async function(e,n){const i=e.getScene(),r=[[10.00787808793857,53.554574397774715],[10.006971374559072,53.55444226566294],[10.006565280581388,53.55467172811441],[10.006569569754523,53.55471724470295],[10.007768697370686,53.554874083634],[10.007848668422987,53.554846301309745],[10.007913475744536,53.554604563663226]].map((([t,n])=>e.latLngAltToVector3({lat:n,lng:t}))),o=function(t){const e=new Float32Array(18*t.length).fill(0),n=new a.Vector3(0,0,31),i=t.map((t=>t.clone().add(n)));for(let n=0,i=t.length;n<i;n++)t[n].toArray(e,6*n),t[(n+1)%i].toArray(e,6*n+3);let r=6*t.length;for(let t=0,n=i.length;t<n;t++)i[t].toArray(e,r+6*t),i[(t+1)%n].toArray(e,r+6*t+3);let o=12*t.length;for(let n=0;n<t.length;n++){const r=t[n],a=i[n];r.toArray(e,o+6*n),a.toArray(e,o+6*n+3)}const s=new l;s.instanceCount=3*t.length,s.setPositions(e);const u=new c({color:16777215,linewidth:2}),d=new M(s,u);return d.computeLineDistances(),d}(r);i.add(o),i.add(function(t){const e=new a.MeshStandardMaterial({transparent:!0,opacity:.5,color:0}),n=new a.Shape;t.forEach(((t,e)=>{0===e?n.moveTo(t.x,t.y):n.lineTo(t.x,t.y)}));const i={depth:31,bevelEnabled:!1},r=new a.ExtrudeGeometry(n,i);return new a.Mesh(r,e)}(r)),i.add(await function(e){return new Promise((n=>{(new a.TextureLoader).load(t(B),(t=>{const i=new a.PlaneGeometry(...z),r=new a.MeshBasicMaterial({map:t,transparent:!0}),o=new a.Mesh(i,r);e.latLngAltToVector3(U,o.position),o.rotateZ(T),n(o)}))}))}(e)),e.update=()=>{const t=performance.now();o.material.resolution.copy(e.getViewportSize()),o.material.color.setHSL(.36*t/30%1,.69,.5),e.requestRedraw()}}(r).then((()=>r.requestRedraw()))})().catch((t=>{console.error("uncaught error in main: ",t)}));
//# sourceMappingURL=wireframe.b7646d0d.js.map
